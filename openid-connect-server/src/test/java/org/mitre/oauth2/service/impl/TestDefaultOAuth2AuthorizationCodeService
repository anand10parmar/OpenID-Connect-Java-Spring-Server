package org.mitre.oauth2.service.impl;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.when;
import java.util.Calendar;
import org.easymock.Mock;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mitre.oauth2.model.AuthenticationHolderEntity;
import org.mitre.oauth2.model.AuthorizationCodeEntity;
import org.mitre.oauth2.repository.AuthenticationHolderRepository;
import org.mitre.oauth2.repository.AuthorizationCodeRepository;
import org.mitre.oauth2.repository.impl.JpaAuthenticationHolderRepository;
import org.mockito.InjectMocks;
import org.mockito.Matchers;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;



@RunWith(MockitoJUnitRunner.class)
public class TestDefaultOAuth2AuthorizationCodeService {
	
	
	private String codeNotFound;
	
	private AuthenticationHolderEntity authHolder;
	
	private AuthorizationCodeEntity entity;
	
	private JpaAuthenticationHolderRepository  authRepo;
	
	//are these 3 mocks important?
	@Mock
	private AuthorizationCodeRepository repository;
	
	@Mock
	private AuthenticationHolderRepository authenticationHolderRepository;
	
	
	//following two mock suggested by justin
	
	
	
	@Mock
	private OAuth2Authentication authentication;
	
	

	@InjectMocks
	private DefaultOAuth2AuthorizationCodeService service;
	
	

	@Before
	public void setUp() {
		Mockito.reset(repository);
		Mockito.reset(authenticationHolderRepository);
		Mockito.when(repository.getByCode(codeNotFound)).thenReturn(null);
		
		codeNotFound = "codeNotFound";
		authHolder = new AuthenticationHolderEntity();
		authHolder.setAuthentication(authentication);
		authenticationHolderRepository.save(authHolder);
		entity = new AuthorizationCodeEntity();
		MockitoAnnotations.initMocks(this);

	}
	

	@Test
	public void testCreateAuthorizationCode(){
		
		OAuth2Request auth2Request = Mockito.mock(OAuth2Request.class);
		Authentication authObj = Mockito.mock(Authentication.class);
		OAuth2Authentication authentication = new OAuth2Authentication(auth2Request, authObj);
		String code = service.createAuthorizationCode(authentication);
		ArgumentCaptor<AuthorizationCodeEntity> argumentCaptor = ArgumentCaptor.forClass(AuthorizationCodeEntity.class);
		Mockito.verify(repository).save(argumentCaptor.capture());
		assertThat(argumentCaptor.getValue(), equalTo(code));
	
		}

	@Test
	public void testConsumeAuthorizationCodeFound() {
		
		 String code = service.createAuthorizationCode(authentication);
		assertEquals(repository.getByCode(code),authHolder);
		when(repository.save(Matchers.isA(AuthorizationCodeEntity.class))).thenReturn(entity);
		
		}

	@Test
	public void testConsumeAuthorizationCodeNotFound() {
		assertThat(null, equalTo(service.consumeAuthorizationCode(codeNotFound)));	
		}
	
	@Test
	public void testCanNotConsumeTwice() {
//		add another test that shows an authorization code
//		can't be consumed twice; try it twice and expect an error on the second one
		
		
		//TODO
		
		}
	
	
	

	@Test
	public void testConsumeAuthorizationCode(){

		doNothing().when(authHolder).setAuthentication(Matchers.isA(OAuth2Authentication.class));
		when(authRepo.save(Matchers.isA(AuthenticationHolderEntity.class))).thenReturn(authHolder);
		}
	
	@Test
	public void testRespositoryGetAndSet() {
		service.setRepository(repository);
		assertEquals(service.getRepository(), repository);			
		}
	
	@Test
	public void testExpirationSecond() {

		service.setAuthCodeExpirationSeconds(10);
		assertEquals(service.getAuthCodeExpirationSeconds(), 10);			
		}
	
	@Test
	public void testCodeAppropiateSecond() {
//      		your suggestion
//			Add another test that checks whether the authorization code that is saved is set with the appropriate seconds.
//			
//			service.setAuthCodeExpiration(99)
//			verify(respository.save(argumentCaptor))
//			assertThat(argumentcaptor.expiration().isEqualTo(Date.now() + 99seconds)
		
//			can you explain me what exactly you are suggesting me in above line as in" argumentcaptor.expiration() 
//			" what is .expiration()?
// 			I have tried like this.
		
		Calendar calendar = Calendar.getInstance(); // gets a calendar using the default time zone and locale.
		calendar.add(Calendar.SECOND, 99);
		service.setAuthCodeExpirationSeconds(99);
		ArgumentCaptor<AuthorizationCodeEntity> argumentCaptor = ArgumentCaptor.forClass(AuthorizationCodeEntity.class);
		Mockito.verify(repository).save(argumentCaptor.capture());
		assertThat(argumentCaptor.capture(), is(equalTo(calendar.getTime()))); //(actual, expected)
		
		}
	

	
}
